# Learned Lessons & Development Mistakes

**Purpose:** Track lessons learned and mistakes made during development to improve AI agent performance and avoid repeating errors. Keep entries concise and AI agent-friendly.
**Note:** Always ask which lessons to include before editing and keep it very consice and sarcastic.

---

## Critical Rules Violations

### Git Commands

- **NEVER use `--no-verify` or any git bypass flags without explicit user permission first**
- Always ask before attempting to bypass any git hooks or verification steps
- This is a critical rule that must be followed without exception

### Commit Standards

- **ALWAYS fix all tests and ESLint errors when committing, regardless of what you were originally working on**
- Never commit with failing tests or linting warnings
- The commit should be clean and pass all checks
- This applies even if the failures are unrelated to your current work

## Development Workflow

### ‚ùå **PowerShell Command Syntax**

- **Problem:** Used `&&` operator in PowerShell (not supported)
- **Correct:** Use separate commands or `;` separator
- **Lesson:** Always use Windows-compatible commands

### ‚ùå **Type Assertions & User Preferences**

- **Problem:** Used `as` and `any` when user prefers Zod
- **User Preference:** "i prefer zod when suitable instead"
- **Lesson:** Use Zod for runtime validation, avoid `as` and `any`

### ‚úÖ **Incremental Refactoring**

- **Approach:** Broke down large refactoring into smaller, testable steps
- **Lesson:** Incremental changes reduce risk and improve debugging

### ‚ùå **Unnecessary Comments**

- **Problem:** Added verbose comments that don't add real value
- **User Preference:** "avoid comments unless really needed and adding real value"
- **Lesson:** Only comment non-obvious logic, let code speak for itself

### üö® **NEVER Touch Generated Files**

- **Problem:** Manually editing Supabase-generated types
- **Rule:** `GENERATED_database.types.ts` is auto-generated by Supabase CLI
- **Setup:** `npm run types:gen` generates and formats the file automatically
- **Lesson:** Only modify files you create, never touch generated files - they'll be overwritten

### üîÑ **Always Regenerate Types After Migrations**

- **Problem:** Database schema changes not reflected in TypeScript types
- **Rule:** Always run `npm run types:gen` after running migrations
- **Command:** `npm run types:gen` in backend package
- **Lesson:** Database changes require type regeneration to maintain type safety

### üîÑ **Migration Number Conflicts**

- **Problem:** Created migration files with numbers that already exist
- **Rule:** Always check existing migration numbers before creating new ones
- **Command:** `Get-ChildItem packages/backend/supabase/migrations/ | Sort-Object Name` to list existing migrations
- **Lesson:** Migration conflicts cause `supabase db push` to fail with "column already exists" errors
- **Fix:** Rename migration files to next available sequence numbers and update internal headers

### ‚ùå **Don't Run Dev Servers**

- **Problem:** Tried to run dev servers automatically
- **Rule:** Always assume servers are running
- **Lesson:** Don't run dev servers - if they're not running, ask the user

### üö® **NEVER Skip Tests Without Confirmation**

- **Problem:** Skipped tests when stuck instead of asking user
- **Rule:** Always ask before skipping tests - user may have preferences
- **Lesson:** When stuck, ask user how to proceed rather than skipping tests

### üö® **NEVER Run Destructive Commands Without Explicit Permission**

- **Problem:** Ran `npm run db:migrate:reset` without asking user first
- **Rule:** ALWAYS ask before running ANY destructive commands, especially database operations
- **Critical:** Supabase commands like `db reset`, `db push`, `migration reset` can destroy data
- **Lesson:** When user can't login, ask what they want to do - don't assume database reset is needed

### üîç **Debug RLS Issues with Detailed Error Messages**

- **Problem:** Generic error messages made debugging RLS policies difficult
- **Rule:** Always improve error handling to show actual error messages for debugging
- **Lesson:** The error "Failed to update user status" was actually "new row violates row-level security policy for table 'audit_logs'"
- **Fix:** Enhanced error logging in auth middleware and admin router to show specific Supabase errors

### üõ†Ô∏è **Use Playwright for Real-Time Debugging**

- **Problem:** Backend logs weren't accessible for debugging authentication issues
- **Rule:** Use browser automation tools to debug frontend-backend interactions
- **Lesson:** Playwright can simulate real user actions and show network requests/errors
- **Fix:** Used Playwright to login as admin and test verification process step-by-step

### üß™ **Test Strategy Preferences**

- **User Preference:** "always prefer playwright tests for ui and interaction. and unit tests for backend and non-react important functions"
- **Rule:**
  - **Playwright E2E** for UI components, user interactions, and full user flows
  - **Unit tests** for backend API endpoints, utility functions, and non-React business logic

### üé≠ **E2E Test Dialog Handling**

- **Problem:** Tests failed when warning dialogs appeared unexpectedly
- **Rule:** Always check for conditional UI elements (dialogs, modals) and handle them appropriately
- **Lesson:** For profile editing with verification warnings, tests must detect dialog presence and click "Continue" to proceed
- **Pattern:** Check `isVisible()` before interacting with conditional elements

### üîß **E2E Test Utility Functions**

- **Problem:** Manual login logic caused test failures and inconsistencies
- **Rule:** Use existing utility functions like `loginAsUser` from auth-helpers instead of manual login
- **Lesson:** Existing utilities handle edge cases and maintain consistency across tests
- **Pattern:** Import and use `loginAsUser(page, 'userType')` instead of manual form filling

### üë• **Role-Based UI Testing**

- **Problem:** Tests didn't cover all user roles and their different UI behaviors
- **Rule:** Test all user roles (help_seeker, admin, super_admin) and verify role-specific UI elements
- **Lesson:** Different roles see different UI elements (verification badges, warning dialogs, etc.)
- **Pattern:** Create separate test suites for each role and verify role-specific behavior
- **Lesson:** Don't waste time on React component unit tests when Playwright covers real user behavior better
- **Focus:** Backend validation, auth logic, database operations, and critical utility functions

### ‚ö° **Run Failed Tests Only When Fixing**

- **Problem:** Running all tests repeatedly when only fixing specific failures
- **Rule:** When fixing or writing new tests, run only failed tests to save time
- **Command:** `npm test -- --grep "failing test name"` or `npm test -- specific-file.spec.ts`
- **Lesson:** Don't waste time running 15 passing tests when you only need to fix 1 failing test

### üßπ **Remove Fake Tests, Keep Meaningful Differences**

- **Problem:** Tests that test nothing or duplicate functionality without meaningful differences
- **Rule:** Only remove tests that are clearly fake (admit they don't test what they claim)
- **Examples:** Tests that "would require clean database" but don't actually test empty state
- **Lesson:** Be conservative - if tests have different contexts, scenarios, or assertions, keep them
- **Result:** Removed 2 fake tests, kept 33 meaningful tests with real coverage

### üéØ **Replace Fake Tests with Real Functionality Tests**

- **Problem:** `verification-transparency.spec.ts` contained only fake tests with non-existent UUIDs
- **Solution:** Completely rewrote with 8 real tests for actual verification transparency features
- **Tests Added:**
  - Verification badge display for verified/unverified users
  - Admin profile transparency links
  - Admin profile verification counts
  - Error handling for non-existent admins
  - Admin contact information display
  - Admin links display (LinkedIn, campaign, Facebook, Telegram URLs)
  - Verification summary explanations
- **Lesson:** When you find fake tests, replace them with tests that validate real business logic
- **Result:** 8 meaningful tests that actually test verification transparency functionality

### üéØ **Fix Playwright Strict Mode Violations**

- **Problem:** `locator.click: Error: strict mode violation: locator resolved to X elements`
- **Cause:** Generic selectors like `text=Pending` match multiple elements in tables/lists
- **Fix:** Use specific selectors like `[role="option"]:has-text("Pending")` for dropdowns
- **Lesson:** Always target the specific element you want, not generic text that appears multiple times
- **Example:** Changed `text=Pending` to `[role="option"]:has-text("Pending")` for dropdown options

### üö® **NEVER Use Static URLs When Environment Variables Exist**

- **Problem:** Hardcoded URLs like `http://localhost:3000` in tests and code
- **Rule:** Always use environment variables for URLs, ports, and endpoints
- **Examples:**
  - ‚ùå `http://localhost:3000` ‚Üí ‚úÖ `process.env['FRONTEND_URL']`
  - ‚ùå `http://localhost:3001` ‚Üí ‚úÖ `process.env['BACKEND_URL']`
- **Lesson:** Static URLs break across environments and make testing unreliable
- **Fix:** Use config files or environment variables for all URL references

### üö® **NEVER Try to Read/Create .env Files - They're Protected**

- **Problem:** Attempted to read or create `.env` files which are gitignored
- **Rule:** `.env` files are protected by globalIgnore and cannot be accessed
- **Lesson:** When user says "environment variables are already there", don't try to create/read `.env` files
- **Fix:** Trust that environment variables exist and focus on using them correctly

### üö® **NEVER Create Isolated Custom Scripts - Use Existing Helpers**

- **Problem:** Created standalone scripts instead of using existing helper functions
- **Rule:** Always use existing helper functions from E2E package for database operations
- **Examples:** Use `createTestUserViaAPI()` from `test-data.ts` instead of custom database scripts
- **Lesson:** The codebase already has utilities - don't reinvent the wheel with isolated scripts
- **Fix:** Leverage existing `auth-helpers.ts` and `test-data.ts` functions for user management

### üö® **NEVER Create Fake Tests - Use Proper Setup/Teardown**

- **Problem:** Creating fake tests just to run setup code
- **Rule:** Use `beforeAll`/`afterAll` for test suite setup, `beforeEach`/`afterEach` for test case setup
- **Examples:** Don't create a test called "setup admin user" - use `beforeAll` to create users
- **Lesson:** Tests should test behavior, not be disguised setup scripts
- **Fix:** Proper setup/teardown in lifecycle hooks, real tests for actual functionality

### üéØ **Make Tests Order-Independent and Flexible**

- **Problem:** Tests failing due to random user ordering or limited test data
- **Solution:** Add conditional logic to handle variable test environments
- **Examples:**
  - Check if navigation buttons are enabled before clicking
  - Use `isVisible()` checks before asserting presence
  - Log informative messages when tests skip optional features
- **Lesson:** Tests should be robust against non-deterministic data and handle edge cases gracefully
- **Result:** Tests work regardless of user order or test data availability

## TypeScript and Zod Best Practices

- Avoid using `unknown` and `any` types in TypeScript and Zod schemas
- Always use strict typing with proper type definitions
- Use Zod schemas for runtime validation with specific, well-defined types
- Prefer explicit error handling over type assertions
- When parsing data, use specific Zod schemas that match the expected structure
- Avoid fallback to generic types - let validation errors surface for debugging
- Prefer reusing generated types from external libraries (like Supabase) when they describe the same thing exactly
- Don't duplicate type definitions when the external library already provides the correct types

### üéØ **Use Assert Functions for Type Narrowing**

- **Problem:** Used `as` keyword and `!` non-null assertions which are hacks
- **Rule:** Always use proper assert functions: `assertNotNull`, `assertNotUndefined`, `assertNotEmptyString`
- **Why:** Assert functions properly narrow TypeScript types and provide runtime validation
- **Examples:**
  - ‚ùå `const user = users[0]!` ‚Üí ‚úÖ `const user = users[0]; assertNotNull(user);`
  - ‚ùå `const text = value as string` ‚Üí ‚úÖ `const text = value; assertNotEmptyString(text);`
- **Lesson:** Assert functions are safer than type assertions and help TypeScript understand your intent
- **Result:** Better type safety and clearer code intent

### üî¢ **Prevent Duplicate Increments with useRef Tracking**

- **Problem:** View count incremented multiple times for same user due to useEffect re-runs
- **Solution:** Use `useRef<Set<string>>` to track already incremented user IDs per session
- **Pattern:** Check tracking set before increment, add ID after successful increment
- **Lesson:** useEffect with dependencies can fire multiple times - use refs for session-based tracking
- **Result:** Each user's view count increments exactly once per session

### üìä **Test with Relative Comparisons for Stability**

- **Problem:** Exact view count assertions fail due to test environment variations
- **Solution:** Use relative comparisons (`>=`, `>`) instead of exact numbers
- **Pattern:** Store initial count, perform action, assert new count >= initial + expected
- **Lesson:** Tests should be resilient to existing data and parallel test runs
- **Result:** Stable tests that validate increment behavior without brittle exact matches

### üéØ **User Card System Refactoring Lessons**

- **Problem:** Bulk user fetching caused performance issues and complex navigation logic
- **Solution:** Single-user fetching with smart navigation based on view counts
- **Key Changes:**
  - Removed `getUsersForCards` procedure, now fetch one user at a time
  - Next button fetches users with `view_count > current` (strict inequality)
  - Previous button uses browser history instead of complex state management
  - Anonymous-only view counting for accurate analytics
- **Lesson:** Simple, focused APIs are better than complex bulk operations
- **Result:** Faster loading, cleaner code, and better user experience

### üö´ **No Fallbacks Policy**

- **Problem:** User explicitly requested "no fkn fallbacks" for sharing data
- **Solution:** Remove all default values and fallback logic, let errors surface
- **Pattern:** Use conditional rendering instead of fallback values
- **Lesson:** Sometimes crashing is better than showing incorrect data
- **Result:** Cleaner error handling and more predictable behavior

### ‚ö° **Immediate Loading Feedback**

- **Problem:** Loading states appeared too late, making UI feel unresponsive
- **Solution:** Set loading state immediately on button clicks, before API calls
- **Pattern:** `setIsNavigating(true)` at start of click handler
- **Lesson:** Users need immediate feedback for perceived performance
- **Result:** UI feels much more responsive and professional

### üîÑ **Loop Prevention in Navigation**

- **Problem:** Navigation could get stuck in infinite loops with equal view counts
- **Solution:** Use strict inequality (`view_count > current`) instead of `>=`
- **Pattern:** `view_count.gt.${currentUser.view_count}` in database queries
- **Lesson:** Always consider edge cases in navigation logic
- **Result:** Robust navigation that never gets stuck

### üé≠ **Playwright Test Configuration**

- **Problem:** Browser closing on test failures made debugging difficult
- **Solution:** Use `headless: false` in Playwright config for visible browser
- **Pattern:** Simple config change instead of complex teardown hooks
- **Lesson:** Sometimes the simplest solution is the best
- **Result:** Easy debugging when tests fail

### üß™ **Remove Test Conditionals**

- **Problem:** User requested "no if, you should know if it should be enabled and act"
- **Solution:** Use explicit assertions instead of conditional logic in tests
- **Pattern:** `await expect(button).toBeEnabled()` before clicking
- **Lesson:** Tests should be deterministic and explicit
- **Result:** More reliable tests that fail fast with clear assertions

### üîó **Supabase Join Processing Function Bug**

- **Problem:** Supabase join `verified_by_admin:verified_by(full_name)` returned correct data but processing function returned null
- **Root Cause:** `processVerifiedByAdmin()` expected array but join returns single object
- **Debug Process:** Used Docker logs to see raw data vs processed data, found the mismatch
- **Fix:** Changed from `z.array(VerifiedByAdminSchema).safeParse(value)` to `VerifiedByAdminSchema.safeParse(value)`
- **Lesson:** When joins return null, check the processing function - the join syntax might be correct but the data processing is wrong
- **Result:** Join now works perfectly, fetching admin names in single query instead of extra API calls

### üéØ **Supabase Client Join Syntax Variations**

- **Problem:** Join syntax `verified_by_admin:users!verified_by(full_name)` returned null despite admin existing
- **Root Cause:** Supabase client join syntax can vary - sometimes returns object, sometimes array
- **Debug Process:** Raw SQL worked perfectly, but client syntax failed
- **Fix:** Changed to `verified_by_admin:verified_by(full_name)` (removed `users!` prefix)
- **Lesson:** Supabase client joins are finicky - test different syntax variations when raw SQL works but client fails
- **Result:** Single query optimization complete - no more extra API calls for admin names

### üö® **Aggressive Validation Strategy**

- **Problem:** User wanted "no fkn fallbacks" and "crash hard" when data is missing
- **Solution:** Removed all fallback logic, made validation throw errors for missing admin data
- **Pattern:** `if (!data.verified_by_admin) throw new Error(...)` for verified users
- **Lesson:** Sometimes crashing is better than showing incomplete data - forces data integrity
- **Result:** System now crashes immediately when verified users lack admin data, ensuring data quality

### üö® **URL ID IS THE CARD DATA - NEVER BREAK SYNC**

- **Problem:** Tried to optimize by removing navigation to avoid redundant API calls
- **Critical Rule:** URL ID and user data MUST be exactly in sync at all times
- **Why:** URL ID IS the card data - users can bookmark, share, and navigate directly to specific cards
- **Lesson:** Never break URL-data sync for performance - the URL is the source of truth for the current card
- **Fix:** Keep navigation and URL updates, optimize the backend queries instead of breaking frontend consistency

## üö® **DATABASE SAFETY - NEVER MODIFY DATA**

- **CRITICAL RULE:** NEVER run database changing commands (db reset, migrations, data modifications)
- **Allowed:** Only read-only database queries for debugging and investigation
- **Why:** Database changes can destroy data, break production, and cause irreversible damage
- **When debugging data issues:** Use SELECT queries to investigate, never modify or reset data
- **Lesson:** Always ask user before any database changes - they own the data, not the assistant
